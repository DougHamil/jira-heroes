// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['battle/payloads/factory', 'battle/animation', 'battle/battlehero', 'battle/battlecard', 'battle/playerfield', 'battle/playerhand', 'jquery', 'gui', 'engine', 'util', 'pixi'], function(PayloadFactory, Animation, BattleHero, BattleCard, PlayerField, PlayerHand, $, GUI, engine, Util) {
    var CardAnimator, DEFAULT_TWEEN_TIME, DISCARD_ORIGIN, ENEMY_DECK_ORIGIN, ENEMY_FIELD_CONFIG, ENEMY_HAND_CONFIG, ENEMY_HERO_ABILITY_POSITION, ENEMY_HERO_POSITION, PLAYER_DECK_ORIGIN, PLAYER_FIELD_CONFIG, PLAYER_HAND_CONFIG, PLAYER_HERO_ABILITY_POSITION, PLAYER_HERO_POSITION;
    PLAYER_DECK_ORIGIN = {
      x: engine.WIDTH + GUI.Card.Width / 2,
      y: engine.HEIGHT - GUI.Card.Height
    };
    ENEMY_DECK_ORIGIN = {
      x: engine.WIDTH + GUI.Card.Width / 2,
      y: GUI.Card.Height
    };
    DISCARD_ORIGIN = {
      x: -200,
      y: 0
    };
    DEFAULT_TWEEN_TIME = 200;
    PLAYER_HERO_POSITION = {
      x: engine.WIDTH - GUI.HeroToken.Width / 2 - 40,
      y: 400 + GUI.HeroToken.Height / 2
    };
    PLAYER_HERO_ABILITY_POSITION = {
      x: engine.WIDTH - GUI.HeroToken.Width - 40,
      y: 400 + GUI.HeroToken.Height + 20
    };
    ENEMY_HERO_POSITION = {
      x: engine.WIDTH - GUI.HeroToken.Width / 2 - 40,
      y: 240 + GUI.HeroToken.Height / 2
    };
    ENEMY_HERO_ABILITY_POSITION = {
      x: engine.WIDTH - GUI.HeroToken.Width - 40,
      y: 240 - GUI.HeroToken.Height - 20
    };
    PLAYER_FIELD_CONFIG = {
      animationTime: 500,
      hoverOffset: {
        x: GUI.CardToken.Width + 20,
        y: 0
      },
      fieldArea: new PIXI.Rectangle(0, 0, engine.WIDTH - 20, 160),
      origin: {
        x: 20 + GUI.CardToken.Width / 2,
        y: engine.HEIGHT / 2 + GUI.CardToken.Height / 2
      },
      padding: 20,
      interactionEnabled: true
    };
    ENEMY_FIELD_CONFIG = {
      animationTime: 500,
      hoverOffset: {
        x: GUI.CardToken.Width + 20,
        y: 0
      },
      fieldArea: new PIXI.Rectangle(0, 0, engine.WIDTH - 20, 160),
      origin: {
        x: 20 + GUI.CardToken.Width / 2,
        y: engine.HEIGHT / 2 - 160 + GUI.CardToken.Height / 2
      },
      padding: 20,
      interactionEnabled: false
    };
    ENEMY_HAND_CONFIG = {
      handHoverOffset: 50,
      origin: {
        x: 20 + GUI.Card.Width / 2,
        y: -100 + GUI.Card.Height / 2
      },
      padding: 20,
      animationTime: DEFAULT_TWEEN_TIME
    };
    PLAYER_HAND_CONFIG = {
      animationTime: DEFAULT_TWEEN_TIME,
      origin: {
        x: 20 + GUI.Card.Width / 2,
        y: engine.HEIGHT + 50 - GUI.Card.Height / 2
      },
      padding: 20,
      hoverOffset: {
        x: 0,
        y: -70
      }
    };
    /*
    # Manages all card sprites in the battle by positioning and animating them
    # as the battle unfolds.
    */

    return CardAnimator = (function(_super) {
      __extends(CardAnimator, _super);

      function CardAnimator(heroClasses, cardClasses, userId, battle) {
        var card, cardId, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3,
          _this = this;
        this.heroClasses = heroClasses;
        this.cardClasses = cardClasses;
        this.userId = userId;
        this.battle = battle;
        CardAnimator.__super__.constructor.apply(this, arguments);
        this.animationQueue = [];
        this.activeAnimation = new Animation();
        this.cards = {};
        this.errorDisplay = new GUI.Error();
        this.yourTurnGraphic = new GUI.YourTurn();
        this.cardSpriteLayer = new PIXI.DisplayObjectContainer();
        this.tokenSpriteLayer = new PIXI.DisplayObjectContainer();
        this.uiLayer = new PIXI.DisplayObjectContainer();
        this.addChild(this.tokenSpriteLayer);
        this.addChild(this.cardSpriteLayer);
        this.addChild(this.uiLayer);
        this.addChild(engine.fxLayer);
        this.playerEnergyIcon = new GUI.EnergyIcon(this.battle.getEnergy());
        this.playerEnergyIcon.anchor = {
          x: 1,
          y: 0
        };
        this.playerEnergyIcon.position = {
          x: engine.WIDTH - this.playerEnergyIcon.width,
          y: 0
        };
        this.uiLayer.addChild(this.playerEnergyIcon);
        this.playerHand = new PlayerHand(PLAYER_HAND_CONFIG, this.uiLayer);
        this.enemyHand = new PlayerHand(ENEMY_HAND_CONFIG, this.uiLayer);
        this.playerField = new PlayerField(PLAYER_FIELD_CONFIG, this.uiLayer);
        this.enemyField = new PlayerField(ENEMY_FIELD_CONFIG, this.uiLayer);
        this.setPlayerHero(this.battle.getHero());
        this.setEnemyHero(this.battle.getEnemyHero());
        _ref = this.battle.getCardsInHand();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          card = _ref[_i];
          this.addCard(card);
          this.putCardInHand(card, false);
        }
        _ref1 = this.battle.getEnemyCardsInHand();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          cardId = _ref1[_j];
          this.addCardId(cardId);
          this.putCardInEnemyHand(cardId, false);
        }
        _ref2 = this.battle.getCardsOnField();
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          card = _ref2[_k];
          this.addCard(card);
          this.putCardOnField(card, false);
        }
        _ref3 = this.battle.getEnemyCardsOnField();
        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
          card = _ref3[_l];
          this.addCard(card);
          this.putCardOnEnemyField(card, false);
        }
        this.playerHand.on('card-dropped', function(battleCard, position) {
          return _this.onCardDropped(battleCard, position);
        });
        this.playerHand.on('card-target', function(battleCard, position) {
          return _this.onCardTarget(battleCard, position);
        });
        this.playerField.on('token-target', function(battleCard, position) {
          return _this.onTokenTarget(battleCard, position);
        });
        engine.updateCallbacks.push(function() {
          return _this.update();
        });
        document.body.onmouseup = function() {
          return _this.onMouseUp();
        };
        this.battle.on('action', function(actions) {
          return _this.handleActions(actions);
        });
        this.errorDisplay.position = {
          x: engine.WIDTH / 2,
          y: engine.HEIGHT / 2
        };
        this.uiLayer.addChild(this.errorDisplay);
        this.uiLayer.addChild(this.yourTurnGraphic);
      }

      CardAnimator.prototype.deactivate = function() {
        return document.body.onmouseup = function() {};
      };

      CardAnimator.prototype.animateAction = function(action) {
        var animation, target,
          _this = this;
        switch (action.type) {
          case 'energy':
            if (action.player === this.battle.getPlayerId()) {
              this.playerEnergyIcon.setEnergy(this.battle.getEnergy());
            }
            break;
          case 'draw-card':
            animation = new Animation();
            if (action.player === this.userId) {
              animation.addAnimationStep(function() {
                var bCard;
                bCard = _this.getBattleCard(action.card);
                bCard.setCardPosition(PLAYER_DECK_ORIGIN);
                bCard.setTokenPosition(PLAYER_DECK_ORIGIN);
                return _this.putCardInHand(action.card, true);
              });
            } else {
              animation.addAnimationStep(function() {
                var bCard;
                bCard = _this.getBattleCard(action.card);
                bCard.setCardPosition(ENEMY_DECK_ORIGIN);
                return _this.putCardInEnemyHand(action.card, true);
              });
            }
            return animation;
          case 'destroy':
            return this.getBattleObject(action.target).animateDestroyed();
          case 'start-turn':
            if (action.player === this.battle.getPlayerId()) {
              return this.yourTurnGraphic.animate();
            }
        }
        if (action.target != null) {
          target = this.getBattleObject(action.target);
          if (target != null) {
            return target.animateAction(action);
          }
        } else if (action.hero != null) {
          target = this.getBattleObject(action.hero);
          if (target != null) {
            return target.animateAction(action);
          }
        }
        return null;
      };

      CardAnimator.prototype.handleActions = function(actions) {
        var action, animation, payload, payloads, _i, _j, _len, _len1;
        for (_i = 0, _len = actions.length; _i < _len; _i++) {
          action = actions[_i];
          this.preprocessAction(action);
        }
        animation = new Animation();
        payloads = PayloadFactory.processActions(this.battle, [].concat(actions));
        for (_j = 0, _len1 = payloads.length; _j < _len1; _j++) {
          payload = payloads[_j];
          if (payload.animate != null) {
            animation.addAnimationStep(payload.animate(this, this.battle));
          }
        }
        animation.addAnimationStep(this.buildReorderAnimation(actions));
        return this.enqueueAnimation(animation);
      };

      CardAnimator.prototype.preprocessAction = function(action) {
        action.animated = false;
        switch (action.type) {
          case 'draw-card':
            if (action.player === this.userId) {
              return this.addCard(this.battle.getCard(action.card));
            } else {
              return this.addCardId(action.card);
            }
            break;
          case 'play-card':
            if (action.player !== this.userId) {
              return this.setCard(action.card._id, action.card);
            }
            break;
          case 'cast-card':
            if (action.player !== this.userId) {
              return this.setCard(action.card._id, action.card);
            }
            break;
          case 'discard-card':
            return this.discardCard(action.card);
        }
      };

      CardAnimator.prototype.discardCard = function(card) {
        var battleCard;
        battleCard = this.getBattleCard(card);
        if (battleCard == null) {
          return null;
        }
        battleCard.setCardInteractive(false);
        battleCard.setTokenInteractive(false);
        if (this.playerHand.hasCard(battleCard)) {
          return this.playerHand.removeCard(battleCard);
        } else if (this.enemyHand.hasCard(battleCard)) {
          return this.enemyHand.removeCard(battleCard);
        } else if (this.playerField.hasCard(battleCard)) {
          return this.playerField.removeCard(battleCard);
        } else if (this.enemyField.hasCard(battleCard)) {
          return this.enemyField.removeCard(battleCard);
        }
      };

      CardAnimator.prototype.animateActions = function(actions) {
        var action, animation, _i, _len;
        animation = new Animation();
        for (_i = 0, _len = actions.length; _i < _len; _i++) {
          action = actions[_i];
          if (!action.animated) {
            animation.addAnimationStep(this.animateAction(action));
          }
        }
        return this.enqueueAnimation(animation);
      };

      CardAnimator.prototype.buildReorderAnimation = function(actions) {
        var _this = this;
        return function() {
          var animation;
          animation = new Animation();
          animation.addAnimationStep(_this.playerHand.buildReorderAnimation());
          animation.addAnimationStep(_this.enemyHand.buildReorderAnimation());
          animation.addAnimationStep(_this.playerField.buildReorderAnimation());
          animation.addAnimationStep(_this.enemyField.buildReorderAnimation());
          return animation;
          /*
          animation = new Animation()
          animSet = {}
          for action in actions
            switch action.type
              when 'discard-card'
                @buildReorderForCard(animSet, @getBattleCard(action.card))
                @discardCard action.card
              when 'play-card'
                @buildReorderForCard(animSet, @getBattleCard(action.card))
          index = 0
          for key, anim of animSet
            if index is 0
              animation.addAnimationStep anim
            else
              animation.addUnchainedAnimationStep anim
            index++
          return animation
          */

        };
      };

      CardAnimator.prototype.buildReorderForCard = function(animSet, battleCard) {
        if (this.playerHand.hasCard(battleCard)) {
          animSet.playerHand = this.playerHand.buildReorderAnimation();
        } else if (this.playerField.hasCard(battleCard)) {
          animSet.playerField = this.playerField.buildReorderAnimation();
        } else if (this.enemyHand.hasCard(battleCard)) {
          animSet.enemyHand = this.enemyHand.buildReorderAnimation();
        } else if (this.enemyField.hasCard(battleCard)) {
          animSet.enemyField = this.enemyField.buildReorderAnimation();
        }
        return console.log(animSet);
      };

      CardAnimator.prototype.enqueueAnimation = function(animation) {
        var _this = this;
        animation.on('complete', function() {
          return _this.playNextAnimation();
        });
        this.animationQueue.push(animation);
        if ((this.activeAnimation == null) || !this.activeAnimation.isPlaying) {
          return this.playNextAnimation();
        }
      };

      CardAnimator.prototype.playNextAnimation = function() {
        if (this.animationQueue.length > 0) {
          this.activeAnimation = this.animationQueue.shift();
          return this.activeAnimation.play();
        }
      };

      CardAnimator.prototype.putCardOnEnemyField = function(card, animate) {
        var animation, battleCard, reorder;
        if (animate == null) {
          animate = true;
        }
        battleCard = this.getBattleCard(card);
        reorder = false;
        if (this.enemyHand.hasCard(battleCard)) {
          this.enemyHand.removeCard(battleCard);
          reorder = true;
        }
        animation = new Animation();
        animation.addAnimationStep(this.enemyField.addCard(battleCard, animate, false));
        return animation;
      };

      CardAnimator.prototype.putCardOnField = function(card, animate) {
        var animation, battleCard, reorder;
        if (animate == null) {
          animate = true;
        }
        battleCard = this.getBattleCard(card);
        reorder = false;
        if (this.playerHand.hasCard(battleCard)) {
          this.playerHand.removeCard(battleCard);
          battleCard.setTokenPosition(battleCard.getCardSprite().position);
          reorder = true;
        }
        animation = new Animation();
        animation.addAnimationStep(this.playerField.addCard(battleCard, animate, true));
        return animation;
      };

      CardAnimator.prototype.putCardInEnemyHand = function(cardId, animate) {
        var battleCard;
        if (animate == null) {
          animate = true;
        }
        battleCard = this.getBattleCard(cardId);
        return this.enemyHand.addCard(battleCard, animate, false);
      };

      CardAnimator.prototype.putCardInHand = function(card, animate) {
        var battleCard;
        if (animate == null) {
          animate = true;
        }
        battleCard = this.getBattleCard(card);
        return this.playerHand.addCard(battleCard, animate, true);
      };

      CardAnimator.prototype.onTokenTarget = function(battleCard, position) {
        var targetCard, _i, _len, _ref,
          _this = this;
        _ref = this.getBattleCardsOnField();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          targetCard = _ref[_i];
          if (targetCard.containsPoint(position)) {
            this.battle.emitUseCardEvent(battleCard.getId(), {
              card: targetCard.getId()
            }, function(err) {
              if (err != null) {
                console.log(err);
                return _this.errorDisplay.showError(err);
              }
            });
            return;
          }
        }
        if (this.playerHero.containsPoint(position)) {
          this.battle.emitUseCardEvent(battleCard.getId(), {
            hero: this.playerHero.getId()
          }, function(err) {
            if (err != null) {
              console.log(err);
              return _this.errorDisplay.showError(err);
            }
          });
          return;
        }
        if (this.enemyHero.containsPoint(position)) {
          this.battle.emitUseCardEvent(battleCard.getId(), {
            hero: this.enemyHero.getId()
          }, function(err) {
            if (err != null) {
              console.log(err);
              return _this.errorDisplay.showError(err);
            }
          });
        }
      };

      CardAnimator.prototype.onCardTarget = function(battleCard, position) {
        var targetCard, _i, _len, _ref,
          _this = this;
        if (battleCard.requiresTarget()) {
          _ref = this.getBattleCardsOnField();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            targetCard = _ref[_i];
            if (targetCard.containsPoint(position)) {
              this.battle.emitPlayCardEvent(battleCard.getId(), {
                card: targetCard.getId()
              }, function(err) {
                if (err != null) {
                  console.log(err);
                  return _this.errorDisplay.showError(err);
                }
              });
              return;
            }
          }
          if (this.playerHero.containsPoint(position)) {
            this.battle.emitPlayCardEvent(battleCard.getId(), {
              hero: this.playerHero.getId()
            }, function(err) {
              if (err != null) {
                console.log(err);
                return _this.errorDisplay.showError(err);
              }
            });
            return;
          }
          if (this.enemyHero.containsPoint(position)) {
            this.battle.emitPlayCardEvent(battleCard.getId(), {
              hero: this.enemyHero.getId()
            }, function(err) {
              if (err != null) {
                console.log(err);
                return _this.errorDisplay.showError(err);
              }
            });
          }
        }
      };

      CardAnimator.prototype.onHeroTarget = function(hero, position) {
        var targetCard, _i, _len, _ref,
          _this = this;
        _ref = this.getBattleCardsOnField();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          targetCard = _ref[_i];
          if (targetCard.containsPoint(position)) {
            this.battle.emitHeroAttackEvent({
              card: targetCard.getId()
            }, function(err) {
              if (err != null) {
                console.log(err);
                return _this.errorDisplay.showError(err);
              }
            });
            return;
          }
        }
        if (this.enemyHero.containsPoint(position)) {
          this.battle.emitHeroAttackEvent({
            hero: this.enemyHero.getId()
          }, function(err) {
            if (err != null) {
              console.log(err);
              return _this.errorDisplay.showError(err);
            }
          });
        }
      };

      CardAnimator.prototype.onHeroAbilityTarget = function(hero, position) {
        var targetCard, _i, _len, _ref,
          _this = this;
        _ref = this.getBattleCardsOnField();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          targetCard = _ref[_i];
          if (targetCard.containsPoint(position)) {
            this.battle.emitUseHeroEvent({
              card: targetCard.getId()
            }, function(err) {
              if (err != null) {
                console.log(err);
                return _this.errorDisplay.showError(err);
              }
            });
            return;
          }
        }
        if (this.enemyHero.containsPoint(position)) {
          this.battle.emitUseHeroEvent({
            hero: this.enemyHero.getId()
          }, function(err) {
            if (err != null) {
              console.log(err);
              return _this.errorDisplay.showError(err);
            }
          });
        }
      };

      CardAnimator.prototype.onHeroCastAbility = function(hero) {
        var _this = this;
        return this.battle.emitUseHeroEvent(null, function(err) {
          if (err != null) {
            console.log(err);
            return _this.errorDisplay.showError(err);
          }
        });
      };

      CardAnimator.prototype.onCardDropped = function(battleCard, position) {
        var _this = this;
        if (this.playerField.containsPoint(position)) {
          return this.battle.emitPlayCardEvent(battleCard.getId(), null, function(err) {
            if (err != null) {
              _this.errorDisplay.showError(err);
              return _this.playerHand.returnCardToHand(battleCard).play();
            } else if ((battleCard.cardClass.rushAbility != null) && battleCard.cardClass.rushAbility.requiresTarget) {
              return _this.playerField.beginTokenTarget(battleCard);
            }
          });
        } else {
          return this.playerHand.returnCardToHand(battleCard).play();
        }
      };

      CardAnimator.prototype.update = function() {
        this.playerHand.update();
        this.enemyHand.update();
        this.playerField.update();
        return this.playerHero.update();
      };

      CardAnimator.prototype.onMouseUp = function() {
        var position;
        position = this.stage.getMousePosition().clone();
        this.playerHand.onMouseUp(position);
        this.enemyHand.onMouseUp(position);
        this.playerField.onMouseUp(position);
        this.enemyField.onMouseUp(position);
        return this.playerHero.onMouseUp(position);
      };

      CardAnimator.prototype.getBattleCardsOnField = function() {
        return this.playerField.getBattleCards().concat(this.enemyField.getBattleCards());
      };

      CardAnimator.prototype.getBattleObject = function(id) {
        if (id._id != null) {
          id = id._id;
        }
        if (this.playerHero.getId() === id) {
          return this.playerHero;
        } else if (this.enemyHero.getId() === id) {
          return this.enemyHero;
        } else {
          return this.getBattleCard(id);
        }
      };

      CardAnimator.prototype.getBattleCard = function(card) {
        if (card._id != null) {
          card = card._id;
        }
        return this.cards[card];
      };

      CardAnimator.prototype.getBattleHero = function(hero) {
        if (hero._id != null) {
          hero = hero._id;
        }
        if (hero === this.playerHero.getId()) {
          return this.playerHero;
        } else if (hero === this.enemyHero.getId()) {
          return this.enemyHero;
        }
        return null;
      };

      CardAnimator.prototype.setCard = function(cardId, card) {
        var battleCard;
        battleCard = this.cards[cardId];
        battleCard.setCard(this.cardClasses[card["class"]], card);
        this.cardSpriteLayer.addChild(battleCard.getCardSprite());
        return this.tokenSpriteLayer.addChild(battleCard.getTokenSprite());
      };

      CardAnimator.prototype.setPlayerHero = function(heroModel) {
        var abilityPopup, abilitySprite, sprite,
          _this = this;
        this.playerHero = new BattleHero(heroModel, this.heroClasses[heroModel["class"]], true, this.uiLayer);
        sprite = this.playerHero.getTokenSprite();
        sprite.position = PLAYER_HERO_POSITION;
        abilitySprite = this.playerHero.getAbilityTokenSprite();
        abilitySprite.position = PLAYER_HERO_ABILITY_POSITION;
        abilityPopup = abilitySprite.getPopupSprite();
        abilityPopup.position = Util.clone(PLAYER_HERO_ABILITY_POSITION);
        abilityPopup.position.x -= abilityPopup.width + 20;
        this.tokenSpriteLayer.addChild(sprite);
        this.tokenSpriteLayer.addChild(abilitySprite);
        this.uiLayer.addChild(abilityPopup);
        this.playerHero.on('hero-target', function(hero, position) {
          return _this.onHeroTarget(hero, position);
        });
        this.playerHero.on('hero-ability-target', function(hero, position) {
          return _this.onHeroAbilityTarget(hero, position);
        });
        return this.playerHero.on('hero-cast-ability', function(hero) {
          return _this.onHeroCastAbility(hero);
        });
      };

      CardAnimator.prototype.setEnemyHero = function(heroModel) {
        var abilityPopup, abilitySprite, sprite;
        this.enemyHero = new BattleHero(heroModel, this.heroClasses[heroModel["class"]], false, this.uiLayer);
        sprite = this.enemyHero.getTokenSprite();
        sprite.position = ENEMY_HERO_POSITION;
        abilitySprite = this.enemyHero.getAbilityTokenSprite();
        abilitySprite.position = ENEMY_HERO_ABILITY_POSITION;
        abilityPopup = abilitySprite.getPopupSprite();
        abilityPopup.position = Util.clone(ENEMY_HERO_ABILITY_POSITION);
        abilityPopup.position.x -= abilityPopup.width + 20;
        this.tokenSpriteLayer.addChild(sprite);
        this.tokenSpriteLayer.addChild(abilitySprite);
        return this.uiLayer.addChild(abilityPopup);
      };

      CardAnimator.prototype.addCardId = function(cardId) {
        var battleCard;
        battleCard = new BattleCard(cardId, null, null);
        this.cards[cardId] = battleCard;
        return this.cardSpriteLayer.addChild(battleCard.getFlippedCardSprite());
      };

      CardAnimator.prototype.addCard = function(card) {
        var battleCard;
        battleCard = new BattleCard(card._id, this.cardClasses[card["class"]], card);
        this.cards[battleCard.getCardId()] = battleCard;
        this.cardSpriteLayer.addChild(battleCard.getFlippedCardSprite());
        this.cardSpriteLayer.addChild(battleCard.getCardSprite());
        return this.tokenSpriteLayer.addChild(battleCard.getTokenSprite());
      };

      CardAnimator.prototype.getCardClass = function(card) {
        return this.cardClasses[card["class"]];
      };

      CardAnimator.prototype.getHeroClass = function(hero) {
        return this.heroClasses[hero["class"]];
      };

      CardAnimator.prototype.getSprite = function(obj) {
        var card;
        if (obj == null) {
          return null;
        }
        if (obj._id != null) {
          obj = obj._id;
        }
        if (this.playerHero.getId() === obj) {
          return this.playerHero.getTokenSprite();
        }
        if (this.enemyHero.getId() === obj) {
          return this.enemyHero.getTokenSprite();
        }
        if (this.cards[obj] != null) {
          card = this.cards[obj];
          if (card.isTokenVisible()) {
            return card.getTokenSprite();
          } else {
            return card.getAvailableCardSprite();
          }
        }
        return null;
      };

      return CardAnimator;

    })(PIXI.DisplayObjectContainer);
  });

}).call(this);
