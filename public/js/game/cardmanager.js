// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['jquery', 'gui', 'engine', 'util', 'pixi'], function($, GUI, engine, Util) {
    var CardManager, DEFAULT_TWEEN_TIME, FIELD_AREA, FIELD_ORIGIN, FIELD_PADDING, HAND_ANIM_TIME, HAND_HOVER_OFFSET, HAND_ORIGIN, HAND_PADDING, HOVER_ANIM_TIME, TOKEN_CARD_OFFSET;
    FIELD_ORIGIN = {
      x: 20,
      y: engine.HEIGHT / 2
    };
    FIELD_PADDING = 50;
    HAND_ORIGIN = {
      x: 20,
      y: engine.HEIGHT - 20
    };
    HAND_ANIM_TIME = 1000;
    HAND_HOVER_OFFSET = 50;
    HAND_PADDING = 20;
    HOVER_ANIM_TIME = 200;
    DEFAULT_TWEEN_TIME = 400;
    TOKEN_CARD_OFFSET = 100;
    FIELD_AREA = new PIXI.Rectangle(20, 200, engine.WIDTH - 80, 500);
    /*
    # Manages all card sprites in the battle by positioning and animating them
    # as the battle unfolds.
    */

    return CardManager = (function(_super) {
      __extends(CardManager, _super);

      function CardManager(cardClasses, userId, battle) {
        var card, _i, _j, _len, _len1, _ref, _ref1,
          _this = this;
        this.cardClasses = cardClasses;
        this.userId = userId;
        this.battle = battle;
        CardManager.__super__.constructor.apply(this, arguments);
        this.cardSprites = {};
        this.tokenSprites = {};
        this.cardTokens = {};
        this.handSprites = [];
        this.fieldSprites = [];
        _ref = this.battle.getCardsInHand();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          card = _ref[_i];
          this.putCardInHand(card, false);
        }
        _ref1 = this.battle.getCardsOnField();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          card = _ref1[_j];
          this.putCardOnField(card, false);
        }
        engine.updateCallbacks.push(function() {
          return _this.update();
        });
        document.body.onmouseup = function() {
          if (_this.targetingSource != null) {
            if (!_this.onTargeted(_this.targetingSource, _this.stage.getMousePosition().clone())) {
              if (_this.targetingSource.dropTween != null) {
                _this.targetingSource.dropTween.start();
              }
            }
            return _this.targetingSource = null;
          }
        };
        this.battle.on('action-draw-card', function(action) {
          return _this.onDrawCardAction(action);
        });
      }

      CardManager.prototype.onDrawCardAction = function(action) {
        if (action.player === this.userId) {
          return this.putCardInHand(action.card);
        }
      };

      CardManager.prototype.putCardOnField = function(card, animate) {
        var addInteraction, cardSprite, position, tokenSprite, tween,
          _this = this;
        if (animate == null) {
          animate = true;
        }
        cardSprite = this.getCardSprite(card);
        tokenSprite = this.getTokenSprite(card);
        position = this.getOpenFieldPosition();
        addInteraction = function(sprite) {
          return function() {
            var cardPos;
            cardPos = Util.clone(sprite.position);
            cardPos.x += sprite.width + TOKEN_CARD_OFFSET;
            sprite.cardSprite.position = cardPos;
            sprite.cardSprite.visible = false;
            sprite.visible = true;
            sprite.onHoverStart(function() {
              return sprite.cardSprite.visible = true;
            });
            sprite.onHoverEnd(function() {
              return sprite.cardSprite.visible = false;
            });
            return sprite.onMouseUp(function() {});
          };
        };
        tokenSprite.visible = false;
        tokenSprite.position = position;
        if (animate) {
          tween = Util.spriteTween(cardSprite, cardSprite.position, position, DEFAULT_TWEEN_TIME);
          cardSprite.tween = tween;
          tween.start();
          tween.onComplete(addInteraction(tokenSprite));
        } else {
          addInteraction(tokenSprite)();
        }
        this.fieldSprites.push(tokenSprite);
        return this.handSprites = this.handSprites.filter(function(s) {
          return s !== cardSprite;
        });
      };

      CardManager.prototype.putCardInHand = function(card, animate) {
        var addInteraction, position, sprite, tween,
          _this = this;
        if (animate == null) {
          animate = true;
        }
        sprite = this.getCardSprite(card);
        position = this.getOpenHandPosition();
        sprite.sourcePosition = position;
        addInteraction = function(sprite) {
          return function() {
            var cardClass, from, to;
            cardClass = _this.cardClasses[sprite.card["class"]];
            to = {
              x: sprite.position.x,
              y: sprite.position.y - HAND_HOVER_OFFSET
            };
            from = {
              x: sprite.position.x,
              y: sprite.position.y
            };
            sprite.onHoverStart(function() {
              var tween;
              if ((_this.dragSprite == null) && (_this.targetingSource == null)) {
                tween = Util.spriteTween(sprite, sprite.position, to, HOVER_ANIM_TIME);
                tween.start();
                return sprite.tween = tween;
              }
            });
            sprite.onHoverEnd(function() {
              var tween;
              if (_this.dragSprite !== sprite && _this.targetingSource !== sprite) {
                tween = Util.spriteTween(sprite, sprite.position, from, HOVER_ANIM_TIME);
                tween.start();
                return sprite.tween = tween;
              } else if (_this.targetingSource === sprite) {
                tween = Util.spriteTween(sprite, sprite.position, from, HOVER_ANIM_TIME);
                return sprite.dropTween = tween;
              }
            });
            sprite.onMouseDown(function() {
              if (cardClass.playAbility != null) {
                return _this.setTargetingSource(sprite);
              } else {
                if (sprite.tween != null) {
                  sprite.tween.stop();
                  _this.dragOffset = _this.stage.getMousePosition().clone();
                  _this.dragOffset.x -= sprite.position.x;
                  _this.dragOffset.y -= sprite.position.y;
                  _this.dragSprite = sprite;
                  _this.removeChild(_this.dragSprite);
                  return _this.addChild(_this.dragSprite);
                }
              }
            });
            return sprite.onMouseUp(function() {
              var tween;
              if (sprite.tween != null) {
                sprite.tween.stop();
              }
              if (_this.dragSprite === sprite) {
                _this.dragSprite = null;
                tween = Util.spriteTween(sprite, sprite.position, from, HOVER_ANIM_TIME);
                sprite.tween = tween;
                return _this.onCardDropped(sprite);
              }
            });
          };
        };
        if (animate) {
          tween = Util.spriteTween(sprite, sprite.position, position, HAND_ANIM_TIME).start();
          sprite.tween = tween;
          tween.onComplete(addInteraction(sprite));
        } else {
          sprite.position = position;
          addInteraction(sprite)();
        }
        return this.handSprites.push(sprite);
      };

      CardManager.prototype.onTargeted = function(sourceSprite, targetPosition) {};

      CardManager.prototype.onCardDropped = function(sprite) {
        var card, cardClass, corner, corners, played, _i, _len,
          _this = this;
        corners = [];
        corners.push(sprite.position);
        corners.push({
          x: sprite.position.x,
          y: sprite.position.y + sprite.height
        });
        corners.push({
          x: sprite.position.x + sprite.width,
          y: sprite.position.y + sprite.height
        });
        corners.push({
          x: sprite.position.x + sprite.width,
          y: sprite.position.y
        });
        played = false;
        for (_i = 0, _len = corners.length; _i < _len; _i++) {
          corner = corners[_i];
          if (FIELD_AREA.contains(corner.x, corner.y)) {
            card = sprite.card;
            cardClass = this.cardClasses[card["class"]];
            this.battle.emitPlayCardEvent(sprite.card._id, null, function(err) {
              if (err != null) {
                console.log(err);
                return sprite.tween.start();
              } else {
                console.log("Played card " + sprite.card._id);
                _this.removeInteractions(sprite);
                _this.putCardOnField(sprite.card);
                if (cardClass.rushAbility != null) {
                  sprite.dropTween = null;
                  return _this.setTargetingSource(sprite);
                }
              }
            });
            played = true;
            break;
          }
        }
        if (!played) {
          return sprite.tween.start();
        }
      };

      CardManager.prototype.removeInteractions = function(cardSprite) {
        return cardSprite.removeAllInteractions();
      };

      CardManager.prototype.update = function() {
        var pos, sourcePos;
        if (this.targetingSprite != null) {
          this.removeChild(this.targetingSprite);
          this.targetingSprite = null;
        }
        if (this.stage != null) {
          if (this.dragSprite != null) {
            pos = this.stage.getMousePosition().clone();
            pos.x -= this.dragOffset.x;
            pos.y -= this.dragOffset.y;
            return this.dragSprite.position = pos;
          } else if (this.targetingSource != null) {
            pos = this.stage.getMousePosition().clone();
            sourcePos = {
              x: this.targetingSource.position.x + this.targetingSource.width / 2,
              y: this.targetingSource.position.y + this.targetingSource.height / 2
            };
            this.targetingSprite = this.createTargetingSprite(sourcePos, pos);
            return this.addChild(this.targetingSprite);
          }
        }
      };

      CardManager.prototype.setTargetingSource = function(sprite) {
        return this.targetingSource = sprite;
      };

      CardManager.prototype.getOpenFieldPosition = function() {
        return {
          x: FIELD_ORIGIN.x + (this.getCardWidth() + FIELD_PADDING) * this.fieldSprites.length,
          y: FIELD_ORIGIN.y - this.getCardHeight()
        };
      };

      CardManager.prototype.getOpenHandPosition = function() {
        return {
          x: HAND_ORIGIN.x + (this.getCardWidth() + HAND_PADDING) * this.handSprites.length,
          y: HAND_ORIGIN.y - this.getCardHeight()
        };
      };

      CardManager.prototype.getCardHeight = function() {
        var id, sprite, _ref;
        _ref = this.cardSprites;
        for (id in _ref) {
          sprite = _ref[id];
          return sprite.height;
        }
        return 0;
      };

      CardManager.prototype.getCardWidth = function() {
        var id, sprite, _ref;
        _ref = this.cardSprites;
        for (id in _ref) {
          sprite = _ref[id];
          return sprite.width;
        }
        return 0;
      };

      CardManager.prototype.getTokenSprite = function(card) {
        var sprite;
        sprite = this.tokenSprites[card._id];
        if (sprite == null) {
          sprite = new GUI.CardToken(card, this.cardClasses[card["class"]]);
          sprite.card = card;
          sprite.cardSprite = this.getCardSprite(card);
          this.tokenSprites[card._id] = sprite;
          this.addChild(sprite);
        }
        return sprite;
      };

      CardManager.prototype.getCardSprite = function(card) {
        var sprite;
        sprite = this.cardSprites[card._id];
        if (sprite == null) {
          sprite = this.buildSpriteForCard(card);
          sprite.card = card;
          this.cardSprites[card._id] = sprite;
          this.addChild(sprite);
        }
        return sprite;
      };

      CardManager.prototype.createTargetingSprite = function(start, end) {
        var s;
        s = new PIXI.Graphics();
        s.beginFill();
        s.lineStyle(10, 0x000000, 1.0);
        s.moveTo(start.x, start.y);
        s.lineTo(end.x, end.y);
        s.endFill();
        return s;
      };

      CardManager.prototype.buildSpriteForCard = function(card) {
        return new GUI.Card(this.cardClasses[card["class"]], card.damage, card.health, card.status);
      };

      return CardManager;

    })(PIXI.DisplayObjectContainer);
  });

}).call(this);
