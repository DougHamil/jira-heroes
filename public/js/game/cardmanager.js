// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['jquery', 'gui', 'engine', 'util', 'pixi'], function($, GUI, engine, Util) {
    var CardManager, DECK_ORIGIN, DEFAULT_TWEEN_TIME, ENEMY_FIELD_ORIGIN, FIELD_AREA, FIELD_ORIGIN, FIELD_PADDING, HAND_ANIM_TIME, HAND_HOVER_OFFSET, HAND_ORIGIN, HAND_PADDING, HOVER_ANIM_TIME, TOKEN_CARD_OFFSET;
    DECK_ORIGIN = {
      x: engine.WIDTH + 200,
      y: engine.HEIGHT
    };
    FIELD_ORIGIN = {
      x: 20,
      y: engine.HEIGHT / 2
    };
    ENEMY_FIELD_ORIGIN = {
      x: 20,
      y: 100
    };
    FIELD_PADDING = 50;
    HAND_ORIGIN = {
      x: 20,
      y: engine.HEIGHT - 20
    };
    HAND_ANIM_TIME = 1000;
    HAND_HOVER_OFFSET = 50;
    HAND_PADDING = 20;
    HOVER_ANIM_TIME = 200;
    DEFAULT_TWEEN_TIME = 400;
    TOKEN_CARD_OFFSET = 100;
    FIELD_AREA = new PIXI.Rectangle(20, 200, engine.WIDTH - 80, 500);
    /*
    # Manages all card sprites in the battle by positioning and animating them
    # as the battle unfolds.
    */

    return CardManager = (function(_super) {
      __extends(CardManager, _super);

      function CardManager(cardClasses, userId, battle) {
        var card, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2,
          _this = this;
        this.cardClasses = cardClasses;
        this.userId = userId;
        this.battle = battle;
        CardManager.__super__.constructor.apply(this, arguments);
        this.cardSprites = {};
        this.tokenSprites = {};
        this.cardTokens = {};
        this.handSprites = [];
        this.fieldSprites = [];
        this.enemyFieldSprites = [];
        this.cardSpriteLayer = new PIXI.DisplayObjectContainer();
        this.tokenSpriteLayer = new PIXI.DisplayObjectContainer();
        this.addChild(this.tokenSpriteLayer);
        this.addChild(this.cardSpriteLayer);
        _ref = this.battle.getCardsInHand();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          card = _ref[_i];
          this.putCardInHand(card, false);
        }
        _ref1 = this.battle.getCardsOnField();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          card = _ref1[_j];
          this.putCardOnField(card, false);
        }
        _ref2 = this.battle.getEnemyCardsOnField();
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          card = _ref2[_k];
          console.log(card);
          this.putEnemyCardOnField(card, false);
        }
        engine.updateCallbacks.push(function() {
          return _this.update();
        });
        document.body.onmouseup = function() {
          if (_this.targetingSource != null) {
            if (!_this.onTargeted(_this.targetingSource, _this.stage.getMousePosition().clone())) {
              if (_this.targetingSource.dropTween != null) {
                _this.targetingSource.dropTween.start();
              }
            }
            return _this.targetingSource = null;
          }
        };
        this.battle.on('action-draw-card', function(action) {
          return _this.onDrawCardAction(action);
        });
        this.battle.on('action-end-turn', function(action) {
          return _this.onEndTurnAction(action);
        });
        this.battle.on('action-play-card', function(action) {
          return _this.onPlayCardAction(action);
        });
        this.battle.on('action-damage', function(action) {
          return _this.onDamageAction(action);
        });
      }

      CardManager.prototype.onDamageAction = function(action) {
        var cardSprite, tokenSprite;
        cardSprite = this.cardSprites[action.target];
        tokenSprite = this.tokenSprites[action.target];
        if (cardSprite != null) {
          cardSprite.setHealth(this.battle.getCard(action.target).health);
        }
        if (tokenSprite) {
          return tokenSprite.setHealth(this.battle.getCard(action.target).health);
        }
      };

      CardManager.prototype.onPlayCardAction = function(action) {
        if (action.player !== this.userId) {
          return this.putEnemyCardOnField(action.card);
        }
      };

      CardManager.prototype.onEndTurnAction = function(action) {
        if (action.player === this.userId) {
          return this.fixHandPositions();
        }
      };

      CardManager.prototype.onDrawCardAction = function(action) {
        if (action.player === this.userId) {
          return this.putCardInHand(action.card);
        }
      };

      CardManager.prototype.placeFieldToken = function(cardSprite, tokenSprite, position, isTargetSource, animate) {
        var addInteraction, tween,
          _this = this;
        addInteraction = function(sprite) {
          return function() {
            var cardPos;
            cardPos = Util.clone(sprite.position);
            cardPos.x += sprite.width + TOKEN_CARD_OFFSET;
            sprite.cardSprite.position = cardPos;
            sprite.cardSprite.visible = false;
            sprite.visible = true;
            sprite.onHoverStart(function() {
              return sprite.cardSprite.visible = true;
            });
            sprite.onHoverEnd(function() {
              return sprite.cardSprite.visible = false;
            });
            if (isTargetSource) {
              return sprite.onMouseDown(function() {
                return _this.setTargetingSource(sprite);
              });
            }
          };
        };
        tokenSprite.visible = false;
        tokenSprite.position = position;
        if (animate) {
          tween = Util.spriteTween(cardSprite, cardSprite.position, position, DEFAULT_TWEEN_TIME);
          cardSprite.tween = tween;
          tween.start();
          return tween.onComplete(addInteraction(tokenSprite));
        } else {
          return addInteraction(tokenSprite)();
        }
      };

      CardManager.prototype.putEnemyCardOnField = function(card, animate) {
        var cardSprite, position, tokenSprite;
        if (animate == null) {
          animate = true;
        }
        cardSprite = this.getCardSprite(card);
        tokenSprite = this.getTokenSprite(card);
        position = this.getOpenEnemyFieldPosition();
        this.placeFieldToken(cardSprite, tokenSprite, position, false, animate);
        return this.enemyFieldSprites.push(tokenSprite);
      };

      CardManager.prototype.putCardOnField = function(card, animate) {
        var cardSprite, position, tokenSprite;
        if (animate == null) {
          animate = true;
        }
        cardSprite = this.getCardSprite(card);
        tokenSprite = this.getTokenSprite(card);
        position = this.getOpenFieldPosition();
        this.placeFieldToken(cardSprite, tokenSprite, position, true, animate);
        this.fieldSprites.push(tokenSprite);
        return this.handSprites = this.handSprites.filter(function(s) {
          return s !== cardSprite;
        });
      };

      CardManager.prototype.setHandInteraction = function(sprite) {
        var cardClass, from, to,
          _this = this;
        cardClass = this.cardClasses[sprite.card["class"]];
        to = {
          x: sprite.position.x,
          y: sprite.position.y - HAND_HOVER_OFFSET
        };
        from = {
          x: sprite.position.x,
          y: sprite.position.y
        };
        sprite.onHoverStart(function() {
          var tween;
          if ((_this.dragSprite == null) && (_this.targetingSource == null)) {
            tween = Util.spriteTween(sprite, sprite.position, to, HOVER_ANIM_TIME);
            tween.start();
            return sprite.tween = tween;
          }
        });
        sprite.onHoverEnd(function() {
          var tween;
          if (_this.dragSprite !== sprite && _this.targetingSource !== sprite) {
            tween = Util.spriteTween(sprite, sprite.position, from, HOVER_ANIM_TIME);
            tween.start();
            return sprite.tween = tween;
          } else if (_this.targetingSource === sprite) {
            tween = Util.spriteTween(sprite, sprite.position, from, HOVER_ANIM_TIME);
            return sprite.dropTween = tween;
          }
        });
        sprite.onMouseDown(function() {
          if (cardClass.playAbility != null) {
            return _this.setTargetingSource(sprite);
          } else {
            if (sprite.tween != null) {
              sprite.tween.stop();
              _this.dragOffset = _this.stage.getMousePosition().clone();
              _this.dragOffset.x -= sprite.position.x;
              _this.dragOffset.y -= sprite.position.y;
              _this.dragSprite = sprite;
              _this.removeChild(_this.dragSprite);
              return _this.addChild(_this.dragSprite);
            }
          }
        });
        return sprite.onMouseUp(function() {
          var tween;
          if (sprite.tween != null) {
            sprite.tween.stop();
          }
          if (_this.dragSprite === sprite) {
            _this.dragSprite = null;
            tween = Util.spriteTween(sprite, sprite.position, from, HOVER_ANIM_TIME);
            sprite.tween = tween;
            return _this.onCardDropped(sprite);
          }
        });
      };

      CardManager.prototype.putCardInHand = function(card, animate) {
        var addInteraction, position, sprite, tween,
          _this = this;
        if (animate == null) {
          animate = true;
        }
        sprite = this.getCardSprite(card);
        position = this.getOpenHandPosition();
        sprite.sourcePosition = position;
        addInteraction = function(sprite) {
          return function() {
            return _this.setHandInteraction(sprite);
          };
        };
        if (animate) {
          if (sprite.position.x === 0 && sprite.position.y === 0) {
            sprite.position = Util.clone(DECK_ORIGIN);
          }
          tween = Util.spriteTween(sprite, sprite.position, position, HAND_ANIM_TIME).start();
          sprite.tween = tween;
          tween.onComplete(addInteraction(sprite));
        } else {
          sprite.position = position;
          addInteraction(sprite)();
        }
        return this.handSprites.push(sprite);
      };

      CardManager.prototype.fixHandPositions = function() {
        var cardSprite, index, pos, setInteractions, _i, _len, _ref, _results,
          _this = this;
        index = 0;
        setInteractions = function(sprite) {
          return function() {
            return _this.setHandInteraction(sprite);
          };
        };
        _ref = this.handSprites;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cardSprite = _ref[_i];
          pos = this.getHandPositionAt(index);
          if (cardSprite.x !== pos.x || cardSprite.y !== pos.y) {
            this.removeInteractions(cardSprite);
            cardSprite.tween = Util.spriteTween(cardSprite, cardSprite.position, pos, HAND_ANIM_TIME);
            cardSprite.tween.start();
            cardSprite.tween.onComplete(setInteractions(cardSprite));
          }
          _results.push(index++);
        }
        return _results;
      };

      CardManager.prototype.onTargeted = function(sourceSprite, targetPosition) {
        var cardId, tokenSprite, _ref, _results,
          _this = this;
        _ref = this.tokenSprites;
        _results = [];
        for (cardId in _ref) {
          tokenSprite = _ref[cardId];
          if (tokenSprite.contains(targetPosition)) {
            if (__indexOf.call(this.handSprites, sourceSprite) >= 0) {
              console.log("Attempting to cast spell of card " + sourceSprite.card._id);
              this.battle.emitPlayCardEvent(sourceSprite.card._id, cardId, function(err) {
                if (err != null) {
                  console.log(err);
                  return sourceSprite.tween.start();
                }
              });
            } else if (__indexOf.call(this.fieldSprites, sourceSprite) >= 0) {
              console.log("Attempting to attack with card " + sourceSprite.card._id);
              this.battle.emitUseCardEvent(sourceSprite.card._id, {
                card: cardId
              }, function(err) {
                if (err != null) {
                  return console.log(err);
                }
              });
            }
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      CardManager.prototype.onCardDropped = function(sprite) {
        var card, cardClass, corner, corners, played, _i, _len,
          _this = this;
        corners = [];
        corners.push(sprite.position);
        corners.push({
          x: sprite.position.x,
          y: sprite.position.y + sprite.height
        });
        corners.push({
          x: sprite.position.x + sprite.width,
          y: sprite.position.y + sprite.height
        });
        corners.push({
          x: sprite.position.x + sprite.width,
          y: sprite.position.y
        });
        played = false;
        for (_i = 0, _len = corners.length; _i < _len; _i++) {
          corner = corners[_i];
          if (FIELD_AREA.contains(corner.x, corner.y)) {
            card = sprite.card;
            cardClass = this.cardClasses[card["class"]];
            this.battle.emitPlayCardEvent(sprite.card._id, null, function(err) {
              if (err != null) {
                console.log(err);
                return sprite.tween.start();
              } else {
                console.log("Played card " + sprite.card._id);
                _this.removeInteractions(sprite);
                _this.putCardOnField(sprite.card);
                if (cardClass.rushAbility != null) {
                  sprite.dropTween = null;
                  return _this.setTargetingSource(_this.getTokenSprite(sprite.card));
                }
              }
            });
            played = true;
            break;
          }
        }
        if (!played) {
          return sprite.tween.start();
        }
      };

      CardManager.prototype.removeInteractions = function(cardSprite) {
        return cardSprite.removeAllInteractions();
      };

      CardManager.prototype.update = function() {
        var pos, sourcePos;
        if (this.targetingSprite != null) {
          this.removeChild(this.targetingSprite);
          this.targetingSprite = null;
        }
        if (this.stage != null) {
          if (this.dragSprite != null) {
            pos = this.stage.getMousePosition().clone();
            pos.x -= this.dragOffset.x;
            pos.y -= this.dragOffset.y;
            return this.dragSprite.position = pos;
          } else if (this.targetingSource != null) {
            pos = this.stage.getMousePosition().clone();
            sourcePos = {
              x: this.targetingSource.position.x + this.targetingSource.width / 2,
              y: this.targetingSource.position.y + this.targetingSource.height / 2
            };
            this.targetingSprite = this.createTargetingSprite(sourcePos, pos);
            return this.addChild(this.targetingSprite);
          }
        }
      };

      CardManager.prototype.setTargetingSource = function(sprite) {
        return this.targetingSource = sprite;
      };

      CardManager.prototype.getHandPositionAt = function(idx) {
        return {
          x: HAND_ORIGIN.x + (this.getCardWidth() + HAND_PADDING) * idx,
          y: HAND_ORIGIN.y - this.getCardHeight()
        };
      };

      CardManager.prototype.getOpenFieldPosition = function() {
        return {
          x: FIELD_ORIGIN.x + (this.getCardWidth() + FIELD_PADDING) * this.fieldSprites.length,
          y: FIELD_ORIGIN.y
        };
      };

      CardManager.prototype.getOpenEnemyFieldPosition = function() {
        return {
          x: ENEMY_FIELD_ORIGIN.x + (this.getCardWidth() + FIELD_PADDING) * this.enemyFieldSprites.length,
          y: ENEMY_FIELD_ORIGIN.y
        };
      };

      CardManager.prototype.getOpenHandPosition = function() {
        return this.getHandPositionAt(this.handSprites.length);
      };

      CardManager.prototype.getCardHeight = function() {
        var id, sprite, _ref;
        _ref = this.cardSprites;
        for (id in _ref) {
          sprite = _ref[id];
          return sprite.height;
        }
        return 0;
      };

      CardManager.prototype.getCardWidth = function() {
        var id, sprite, _ref;
        _ref = this.cardSprites;
        for (id in _ref) {
          sprite = _ref[id];
          return sprite.width;
        }
        return 0;
      };

      CardManager.prototype.getTokenSprite = function(card) {
        var sprite;
        sprite = this.tokenSprites[card._id];
        if (sprite == null) {
          sprite = new GUI.CardToken(card, this.cardClasses[card["class"]]);
          sprite.card = card;
          sprite.cardSprite = this.getCardSprite(card);
          this.tokenSprites[card._id] = sprite;
          this.tokenSpriteLayer.addChild(sprite);
        }
        return sprite;
      };

      CardManager.prototype.getCardSprite = function(card) {
        var sprite;
        sprite = this.cardSprites[card._id];
        if (sprite == null) {
          sprite = this.buildSpriteForCard(card);
          sprite.card = card;
          this.cardSprites[card._id] = sprite;
          this.cardSpriteLayer.addChild(sprite);
        }
        return sprite;
      };

      CardManager.prototype.createTargetingSprite = function(start, end) {
        var s;
        s = new PIXI.Graphics();
        s.beginFill();
        s.lineStyle(10, 0x000000, 1.0);
        s.moveTo(start.x, start.y);
        s.lineTo(end.x, end.y);
        s.endFill();
        return s;
      };

      CardManager.prototype.buildSpriteForCard = function(card) {
        return new GUI.Card(this.cardClasses[card["class"]], card.damage, card.health, card.status);
      };

      return CardManager;

    })(PIXI.DisplayObjectContainer);
  });

}).call(this);
